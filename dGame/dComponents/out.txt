#include "GameDependencies.h"
#include <gtest/gtest.h>

#include "BitStream.h"
#include "DestroyableComponent.h"
#include "Entity.h"
TEST_F(BaseCombatAITest, BaseCombatAIComponentConstructionTest) {
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(uint32_t(m_State)); //  uint32_t(m_State)
	outBitStream->Read(m_Target); //  m_Target
	} 
  
TEST_F(BouncerTest, BouncerComponentConstructionTest) {
	outBitStream->Read(m_PetEnabled); //  m_PetEnabled
	outBitStream->Read(m_PetBouncerEnabled); //  m_PetBouncerEnabled
	} 
  
TEST_F(BuffTest, BuffComponentConstructionTest) {
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_Buffs.size()); // uint32_t m_Buffs.size()
	outBitStream->Read(buff.first); // uint32_t buff.first
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(0); // uint32_t 0
	outBitStream->ReadBit(); // bool 
	} 
  
TEST_F(CharacterTest, CharacterComponentConstructionTest) {
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_Character->GetHairColor()); //  m_Character->GetHairColor()
	outBitStream->Read(m_Character->GetHairStyle()); //  m_Character->GetHairStyle()
	outBitStream->Read(0); // uint32_t 0
	outBitStream->Read(m_Character->GetShirtColor()); //  m_Character->GetShirtColor()
	outBitStream->Read(m_Character->GetPantsColor()); //  m_Character->GetPantsColor()
	outBitStream->Read(m_Character->GetShirtStyle()); //  m_Character->GetShirtStyle()
	outBitStream->Read(0); // uint32_t 0
	outBitStream->Read(m_Character->GetEyebrows()); //  m_Character->GetEyebrows()
	outBitStream->Read(m_Character->GetEyes()); //  m_Character->GetEyes()
	outBitStream->Read(m_Character->GetMouth()); //  m_Character->GetMouth()
	outBitStream->Read(0); // uint64_t 0
	outBitStream->Read(m_Character->GetLastLogin()); //  m_Character->GetLastLogin()
	outBitStream->Read(0); // uint64_t 0
	outBitStream->Read(m_Uscore); // uint64_t m_Uscore
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_CurrencyCollected); //  m_CurrencyCollected
	outBitStream->Read(m_BricksCollected); //  m_BricksCollected
	outBitStream->Read(m_SmashablesSmashed); //  m_SmashablesSmashed
	outBitStream->Read(m_QuickBuildsCompleted); //  m_QuickBuildsCompleted
	outBitStream->Read(m_EnemiesSmashed); //  m_EnemiesSmashed
	outBitStream->Read(m_RocketsUsed); //  m_RocketsUsed
	outBitStream->Read(m_MissionsCompleted); //  m_MissionsCompleted
	outBitStream->Read(m_PetsTamed); //  m_PetsTamed
	outBitStream->Read(m_ImaginationPowerUpsCollected); //  m_ImaginationPowerUpsCollected
	outBitStream->Read(m_LifePowerUpsCollected); //  m_LifePowerUpsCollected
	outBitStream->Read(m_ArmorPowerUpsCollected); //  m_ArmorPowerUpsCollected
	outBitStream->Read(m_MetersTraveled); //  m_MetersTraveled
	outBitStream->Read(m_TimesSmashed); //  m_TimesSmashed
	outBitStream->Read(m_TotalDamageTaken); //  m_TotalDamageTaken
	outBitStream->Read(m_TotalDamageHealed); //  m_TotalDamageHealed
	outBitStream->Read(m_TotalArmorRepaired); //  m_TotalArmorRepaired
	outBitStream->Read(m_TotalImaginationRestored); //  m_TotalImaginationRestored
	outBitStream->Read(m_TotalImaginationUsed); //  m_TotalImaginationUsed
	outBitStream->Read(m_DistanceDriven); //  m_DistanceDriven
	outBitStream->Read(m_TimeAirborneInCar); //  m_TimeAirborneInCar
	outBitStream->Read(m_RacingImaginationPowerUpsCollected); //  m_RacingImaginationPowerUpsCollected
	outBitStream->Read(m_RacingImaginationCratesSmashed); //  m_RacingImaginationCratesSmashed
	outBitStream->Read(m_RacingCarBoostsActivated); //  m_RacingCarBoostsActivated
	outBitStream->Read(m_RacingTimesWrecked); //  m_RacingTimesWrecked
	outBitStream->Read(m_RacingSmashablesSmashed); //  m_RacingSmashablesSmashed
	outBitStream->Read(m_RacesFinished); //  m_RacesFinished
	outBitStream->Read(m_FirstPlaceRaceFinishes); //  m_FirstPlaceRaceFinishes
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_IsLanding); //  m_IsLanding
	outBitStream->Read(uint16_t(m_LastRocketConfig.size())); //  uint16_t(m_LastRocketConfig.size())
	outBitStream->Read(character); //  character
	outBitStream->Read(m_DirtyGMInfo); //  m_DirtyGMInfo
	outBitStream->Read(m_PvpEnabled); //  m_PvpEnabled
	outBitStream->Read(m_IsGM); //  m_IsGM
	outBitStream->Read(m_GMLevel); //  m_GMLevel
	outBitStream->Read(m_EditorEnabled); //  m_EditorEnabled
	outBitStream->Read(m_EditorLevel); //  m_EditorLevel
	outBitStream->Read(m_DirtyCurrentActivity); //  m_DirtyCurrentActivity
	if (m_DirtyCurrentActivity) outBitStream->Read(m_CurrentActivity); //  m_DirtyCurrentActivity) outBitStream->Read(m_CurrentActivity
	outBitStream->Read(m_DirtySocialInfo); //  m_DirtySocialInfo
	outBitStream->Read(m_GuildID); //  m_GuildID
	outBitStream->Read(static_cast<unsigned char>(m_GuildName.size())); // unsigned char static_cast<unsigned char>(m_GuildName.size())
	outBitStream->WriteBits(reinterpret_cast<const unsigned char*>(m_GuildName.c_str()), static_cast<unsigned char>(m_GuildName.size()) * sizeof(wchar_t) * 8); //  reinterpret_cast<const unsigned char*>(m_GuildName.c_str()), static_cast<unsigned char>(m_GuildName.size()) * sizeof(wchar_t) * 8
	outBitStream->Read(m_IsLEGOClubMember); //  m_IsLEGOClubMember
	outBitStream->Read(m_CountryCode); //  m_CountryCode
	} 
  
TEST_F(ControllablePhysicsTest, ControllablePhysicsComponentConstructionTest) {
	outBitStream->Read(m_InJetpackMode); //  m_InJetpackMode
	outBitStream->Read(m_JetpackEffectID); //  m_JetpackEffectID
	outBitStream->Read(m_JetpackFlying); //  m_JetpackFlying
	outBitStream->Read(m_JetpackBypassChecks); //  m_JetpackBypassChecks
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_DirtyCheats); //  m_DirtyCheats
	outBitStream->Read(m_GravityScale); //  m_GravityScale
	outBitStream->Read(m_SpeedMultiplier); //  m_SpeedMultiplier
	outBitStream->Read(m_DirtyPickupRadiusScale); //  m_DirtyPickupRadiusScale
	outBitStream->Read(m_PickupRadius); //  m_PickupRadius
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_DirtyPosition || bIsInitialUpdate); //  m_DirtyPosition || bIsInitialUpdate
	outBitStream->Read(m_Position.x); //  m_Position.x
	outBitStream->Read(m_Position.y); //  m_Position.y
	outBitStream->Read(m_Position.z); //  m_Position.z
	outBitStream->Read(m_Rotation.x); //  m_Rotation.x
	outBitStream->Read(m_Rotation.y); //  m_Rotation.y
	outBitStream->Read(m_Rotation.z); //  m_Rotation.z
	outBitStream->Read(m_Rotation.w); //  m_Rotation.w
	outBitStream->Read(m_IsOnGround); //  m_IsOnGround
	outBitStream->Read(m_IsOnRail); //  m_IsOnRail
	outBitStream->Read(m_DirtyVelocity); //  m_DirtyVelocity
	outBitStream->Read(m_Velocity.x); //  m_Velocity.x
	outBitStream->Read(m_Velocity.y); //  m_Velocity.y
	outBitStream->Read(m_Velocity.z); //  m_Velocity.z
	outBitStream->Read(m_DirtyAngularVelocity); //  m_DirtyAngularVelocity
	outBitStream->Read(m_AngularVelocity.x); //  m_AngularVelocity.x
	outBitStream->Read(m_AngularVelocity.y); //  m_AngularVelocity.y
	outBitStream->Read(m_AngularVelocity.z); //  m_AngularVelocity.z
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_IsTeleporting); //  m_IsTeleporting
	} 
  
TEST_F(DestroyableTest, DestroyableComponentConstructionTest) {
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_DirtyHealth || bIsInitialUpdate); //  m_DirtyHealth || bIsInitialUpdate
	outBitStream->Read(m_iHealth); //  m_iHealth
	outBitStream->Read(m_fMaxHealth); //  m_fMaxHealth
	outBitStream->Read(m_iArmor); //  m_iArmor
	outBitStream->Read(m_fMaxArmor); //  m_fMaxArmor
	outBitStream->Read(m_iImagination); //  m_iImagination
	outBitStream->Read(m_fMaxImagination); //  m_fMaxImagination
	outBitStream->Read(m_DamageToAbsorb); //  m_DamageToAbsorb
	outBitStream->Read(IsImmune()); //  IsImmune()
	outBitStream->Read(m_IsGMImmune); //  m_IsGMImmune
	outBitStream->Read(m_IsShielded); //  m_IsShielded
	outBitStream->Read(m_fMaxHealth); //  m_fMaxHealth
	outBitStream->Read(m_fMaxArmor); //  m_fMaxArmor
	outBitStream->Read(m_fMaxImagination); //  m_fMaxImagination
	outBitStream->Read(uint32_t(m_FactionIDs.size())); //  uint32_t(m_FactionIDs.size())
	for (size_t i = 0; i < m_FactionIDs.size(); //  size_t i = 0; i < m_FactionIDs.size(
	outBitStream->Read(m_FactionIDs[i]); //  m_FactionIDs[i]
	outBitStream->Read(m_IsSmashable); //  m_IsSmashable
	outBitStream->Read(m_IsDead); //  m_IsDead
	outBitStream->Read(m_IsSmashed); //  m_IsSmashed
	outBitStream->Read(m_HasBricks); //  m_HasBricks
	outBitStream->Read(m_ExplodeFactor != 1.0f); //  m_ExplodeFactor != 1.0f
	if (m_ExplodeFactor != 1.0f) outBitStream->Read(m_ExplodeFactor); //  m_ExplodeFactor != 1.0f) outBitStream->Read(m_ExplodeFactor
	outBitStream->Read(m_DirtyThreatList || bIsInitialUpdate); //  m_DirtyThreatList || bIsInitialUpdate
	outBitStream->Read(m_HasThreats); //  m_HasThreats
	} 
  
TEST_F(InventoryTest, InventoryComponentConstructionTest) {
	outBitStream->Read(true); //  true
	outBitStream->Read(m_Equipped.size()); // uint32_t m_Equipped.size()
	AddItemSkills(item.lot); //  item.lot
	outBitStream->Read(item.id); //  item.id
	outBitStream->Read(item.lot); //  item.lot
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(item.count > 0); //  item.count > 0
	if (item.count > 0) outBitStream->Read(item.count); //  item.count > 0) outBitStream->Read(item.count
	outBitStream->Read(item.slot != 0); //  item.slot != 0
	if (item.slot != 0) outBitStream->Read(item.slot); // uint16_t item.slot != 0) outBitStream->Read(item.slot
	outBitStream->ReadBit(); // bool 
	bool flag = !item.config.empty(); //  
	outBitStream->Read(flag); //  flag
	ldfStream.Read(item.config.size()); // int32_t item.config.size()
	GeneralUtils::ReplaceInString(newRocketStr, "+", ";"); //  newRocketStr, "+", ";"
	LDFData<std::u16string>* ldf_data = new LDFData<std::u16string>(u"assemblyPartLOTs", GeneralUtils::ASCIIToUTF16(newRocketStr)); //  u"assemblyPartLOTs", GeneralUtils::ASCIIToUTF16(newRocketStr)
	ldf_data->WriteToPacket(&ldfStream); //  &ldfStream
	data->WriteToPacket(&ldfStream); //  &ldfStream
	outBitStream->Read(ldfStream.GetNumberOfBytesUsed() + 1); //  ldfStream.GetNumberOfBytesUsed() + 1
	outBitStream->Read(0); // uint8_t 0
	outBitStream->Read(ldfStream); //  ldfStream
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(false); //  false
	outBitStream->Read(false); //  false
	} 
  
TEST_F(LevelProgressionTest, LevelProgressionComponentConstructionTest) {
	outBitStream->Read(bIsInitialUpdate || m_DirtyLevelInfo); //  bIsInitialUpdate || m_DirtyLevelInfo
	if (bIsInitialUpdate || m_DirtyLevelInfo) outBitStream->Read(m_Level); //  bIsInitialUpdate || m_DirtyLevelInfo) outBitStream->Read(m_Level
	} 
  
TEST_F(LUPExhibitTest, LUPExhibitComponentConstructionTest) {
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_Exhibit); //  m_Exhibit
	} 
  
TEST_F(ModelTest, ModelComponentConstructionTest) {
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_userModelID != LWOOBJID_EMPTY ? m_userModelID : m_Parent->GetObjectID()); // LWOOBJID m_userModelID != LWOOBJID_EMPTY ? m_userModelID : m_Parent->GetObjectID()
	outBitStream->Read(0); // int 0
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(2); // uint32_t 2
	outBitStream->Read(m_OriginalPosition); //  m_OriginalPosition
	outBitStream->Read(m_OriginalRotation); //  m_OriginalRotation
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(0); // uint32_t 0
	outBitStream->ReadBit(); // bool 
	if (bIsInitialUpdate) outBitStream->ReadBit(); // bool bIsInitialUpdate) outBitStream->ReadBit(
	} 
  
TEST_F(ModuleAssemblyTest, ModuleAssemblyComponentConstructionTest) {
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_SubKey != LWOOBJID_EMPTY); //  m_SubKey != LWOOBJID_EMPTY
	outBitStream->Read(m_SubKey); //  m_SubKey
	outBitStream->Read(m_UseOptionalParts); //  m_UseOptionalParts
	outBitStream->Read(static_cast<uint16_t>(m_AssemblyPartsLOTs.size())); //  static_cast<uint16_t>(m_AssemblyPartsLOTs.size())
	outBitStream->Read(character); //  character
	} 
  
TEST_F(MoverSubTest, MoverSubComponentConstructionTest) {
	outBitStream->Read(true); // bool true
	outBitStream->Read(static_cast<uint32_t>(mState)); // uint32_t static_cast<uint32_t>(mState)
	outBitStream->Read(mDesiredWaypointIndex); // int32_t mDesiredWaypointIndex
	outBitStream->Read(mShouldStopAtDesiredWaypoint); //  mShouldStopAtDesiredWaypoint
	outBitStream->Read(mInReverse); //  mInReverse
	outBitStream->Read(mPercentBetweenPoints); // float_t mPercentBetweenPoints
	outBitStream->Read(mPosition.x); // float_t mPosition.x
	outBitStream->Read(mPosition.y); // float_t mPosition.y
	outBitStream->Read(mPosition.z); // float_t mPosition.z
	outBitStream->Read(mCurrentWaypointIndex); // uint32_t mCurrentWaypointIndex
	outBitStream->Read(mNextWaypointIndex); // uint32_t mNextWaypointIndex
	outBitStream->Read(mIdleTimeElapsed); // float_t mIdleTimeElapsed
	outBitStream->Read(0.0f); // float_t 0.0f
	} 
  
TEST_F(PetTest, PetComponentConstructionTest) {
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(static_cast<unsigned int>(m_Status)); // uint32_t static_cast<unsigned int>(m_Status)
	outBitStream->Read(static_cast<uint32_t>(tamed ? m_Ability : PetAbilityType::Invalid)); // uint32_t static_cast<uint32_t>(tamed ? m_Ability : PetAbilityType::Invalid)
	outBitStream->Read(interacting); //  interacting
	outBitStream->Read(m_Interaction); //  m_Interaction
	outBitStream->Read(tamed); //  tamed
	outBitStream->Read(m_Owner); //  m_Owner
	outBitStream->Read(tamed); //  tamed
	outBitStream->Read(m_ModerationStatus); //  m_ModerationStatus
	const auto nameData = GeneralUtils::UTF8ToUTF16(m_Name); //  m_Name
	const auto ownerNameData = GeneralUtils::UTF8ToUTF16(m_OwnerName); //  m_OwnerName
	outBitStream->Read(static_cast<uint8_t>(nameData.size())); //  static_cast<uint8_t>(nameData.size())
	outBitStream->Read(c); //  c
	outBitStream->Read(static_cast<uint8_t>(ownerNameData.size())); //  static_cast<uint8_t>(ownerNameData.size())
	outBitStream->Read(c); //  c
	} 
  
TEST_F(PhantomPhysicsTest, PhantomPhysicsComponentConstructionTest) {
	outBitStream->Read(m_PositionInfoDirty || bIsInitialUpdate); //  m_PositionInfoDirty || bIsInitialUpdate
	outBitStream->Read(m_Position.x); //  m_Position.x
	outBitStream->Read(m_Position.y); //  m_Position.y
	outBitStream->Read(m_Position.z); //  m_Position.z
	outBitStream->Read(m_Rotation.x); //  m_Rotation.x
	outBitStream->Read(m_Rotation.y); //  m_Rotation.y
	outBitStream->Read(m_Rotation.z); //  m_Rotation.z
	outBitStream->Read(m_Rotation.w); //  m_Rotation.w
	outBitStream->Read(m_EffectInfoDirty || bIsInitialUpdate); //  m_EffectInfoDirty || bIsInitialUpdate
	outBitStream->Read(m_IsPhysicsEffectActive); //  m_IsPhysicsEffectActive
	outBitStream->Read(m_EffectType); //  m_EffectType
	outBitStream->Read(m_DirectionalMultiplier); //  m_DirectionalMultiplier
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_IsDirectional); //  m_IsDirectional
	outBitStream->Read(m_Direction.x); //  m_Direction.x
	outBitStream->Read(m_Direction.y); //  m_Direction.y
	outBitStream->Read(m_Direction.z); //  m_Direction.z
	} 
  
TEST_F(PlayerForcedMovementTest, PlayerForcedMovementComponentConstructionTest) {
	outBitStream->Read(m_DirtyInfo); //  m_DirtyInfo
	outBitStream->Read(m_PlayerOnRail); //  m_PlayerOnRail
	outBitStream->Read(m_ShowBillboard); //  m_ShowBillboard
	} 
  
TEST_F(PossessableTest, PossessableComponentConstructionTest) {
	outBitStream->Read(m_DirtyPossessable || bIsInitialUpdate); //  m_DirtyPossessable || bIsInitialUpdate
	outBitStream->Read(m_Possessor != LWOOBJID_EMPTY); //  m_Possessor != LWOOBJID_EMPTY
	if (m_Possessor != LWOOBJID_EMPTY) outBitStream->Read(m_Possessor); //  m_Possessor != LWOOBJID_EMPTY) outBitStream->Read(m_Possessor
	outBitStream->Read(m_AnimationFlag != eAnimationFlags::IDLE_NONE); //  m_AnimationFlag != eAnimationFlags::IDLE_NONE
	if (m_AnimationFlag != eAnimationFlags::IDLE_NONE) outBitStream->Read(m_AnimationFlag); //  m_AnimationFlag != eAnimationFlags::IDLE_NONE) outBitStream->Read(m_AnimationFlag
	outBitStream->Read(m_ImmediatelyDepossess); //  m_ImmediatelyDepossess
	} 
  
TEST_F(PossessorTest, PossessorComponentConstructionTest) {
	outBitStream->Read(m_DirtyPossesor || bIsInitialUpdate); //  m_DirtyPossesor || bIsInitialUpdate
	outBitStream->Read(m_Possessable != LWOOBJID_EMPTY); //  m_Possessable != LWOOBJID_EMPTY
	outBitStream->Read(m_Possessable); //  m_Possessable
	outBitStream->Read(m_PossessableType); //  m_PossessableType
	} 
  
TEST_F(RacingControlTest, RacingControlComponentConstructionTest) {
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(static_cast<uint32_t>(m_RacingPlayers.size())); //  static_cast<uint32_t>(m_RacingPlayers.size())
	outBitStream->Read(player.playerID); //  player.playerID
	outBitStream->Read(player.data[i]); //  player.data[i]
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(static_cast<uint16_t>(m_RacingPlayers.size())); //  static_cast<uint16_t>(m_RacingPlayers.size())
	outBitStream->Read(!m_RacingPlayers.empty()); //  !m_RacingPlayers.empty()
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(player.playerID); //  player.playerID
	outBitStream->Read(player.vehicleID); //  player.vehicleID
	outBitStream->Read(player.playerIndex); //  player.playerIndex
	outBitStream->Read(player.playerLoaded); //  player.playerLoaded
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(!m_RacingPlayers.empty()); //  !m_RacingPlayers.empty()
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(player.playerID); //  player.playerID
	outBitStream->Read(0); // uint32_t 0
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_RemainingLaps); //  m_RemainingLaps
	outBitStream->Read(static_cast<uint16_t>(m_PathName.size())); //  static_cast<uint16_t>(m_PathName.size())
	outBitStream->Read(character); //  character
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_LeadingPlayer); //  m_LeadingPlayer
	outBitStream->Read(m_RaceBestLap); //  m_RaceBestLap
	outBitStream->Read(m_RaceBestTime); //  m_RaceBestTime
	} 
  
TEST_F(RebuildTest, RebuildComponentConstructionTest) {
	outBitStream->Read(false); //  false
	outBitStream->Read(false); //  false
	outBitStream->Read(false); //  false
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	Entity* builder = GetBuilder(); //  
	outBitStream->Read((uint32_t)1); //  (uint32_t)1
	outBitStream->Read(builder->GetObjectID()); //  builder->GetObjectID()
	outBitStream->Read(0.0f); //  0.0f
	outBitStream->Read((uint32_t)0); //  (uint32_t)0
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_State); // uint32_t m_State
	outBitStream->Read(m_ShowResetEffect); //  m_ShowResetEffect
	outBitStream->Read(m_Activator != nullptr); //  m_Activator != nullptr
	outBitStream->Read(m_Timer); //  m_Timer
	outBitStream->Read(m_TimerIncomplete); //  m_TimerIncomplete
	outBitStream->Read(false); //  false
	outBitStream->Read(m_ActivatorPosition); //  m_ActivatorPosition
	outBitStream->Read(m_RepositionPlayer); //  m_RepositionPlayer
	} 
  
TEST_F(RenderTest, RenderComponentConstructionTest) {
	outBitStream->Read(m_Effects.size()); // uint32_t m_Effects.size()
	assert(eff); //  eff
	outBitStream->Read(eff->name.size()); // uint8_t eff->name.size()
	outBitStream->Read(value); // uint8_t value
	outBitStream->Read(eff->effectID); //  eff->effectID
	outBitStream->Read(eff->type.size()); // uint8_t eff->type.size()
	outBitStream->Read(value); // uint16_t value
	outBitStream->Read(eff->scale); // float_t eff->scale
	outBitStream->Read(eff->secondary); // int64_t eff->secondary
	} 
  
TEST_F(RigidbodyPhantomPhysicsTest, RigidbodyPhantomPhysicsComponentConstructionTest) {
	outBitStream->Read(m_IsDirty || bIsInitialUpdate); //  m_IsDirty || bIsInitialUpdate
	outBitStream->Read(m_Position.x); //  m_Position.x
	outBitStream->Read(m_Position.y); //  m_Position.y
	outBitStream->Read(m_Position.z); //  m_Position.z
	outBitStream->Read(m_Rotation.x); //  m_Rotation.x
	outBitStream->Read(m_Rotation.y); //  m_Rotation.y
	outBitStream->Read(m_Rotation.z); //  m_Rotation.z
	outBitStream->Read(m_Rotation.w); //  m_Rotation.w
	} 
  
TEST_F(ScriptedActivityTest, ScriptedActivityComponentConstructionTest) {
	outBitStream->Read(true); //  true
	outBitStream->Read(m_ActivityPlayers.size()); // uint32_t m_ActivityPlayers.size()
	outBitStream->Read(activityPlayer->playerID); // LWOOBJID activityPlayer->playerID
	outBitStream->Read(activityValue); // float_t activityValue
	} 
  
TEST_F(ShootingGalleryTest, ShootingGalleryComponentConstructionTest) {
	outBitStream->Read(true); // bool true
	outBitStream->Read(0); // uint32_t 0
	outBitStream->Read(1); // uint32_t 1
	outBitStream->Read(0.0f); // float_t 0.0f
	outBitStream->Read(m_StaticParams.cameraPosition.GetX()); // float_t m_StaticParams.cameraPosition.GetX()
	outBitStream->Read(m_StaticParams.cameraPosition.GetY()); // float_t m_StaticParams.cameraPosition.GetY()
	outBitStream->Read(m_StaticParams.cameraPosition.GetZ()); // float_t m_StaticParams.cameraPosition.GetZ()
	outBitStream->Read(m_StaticParams.cameraLookatPosition.GetX()); // float_t m_StaticParams.cameraLookatPosition.GetX()
	outBitStream->Read(m_StaticParams.cameraLookatPosition.GetY()); // float_t m_StaticParams.cameraLookatPosition.GetY()
	outBitStream->Read(m_StaticParams.cameraLookatPosition.GetZ()); // float_t m_StaticParams.cameraLookatPosition.GetZ()
	outBitStream->Read(m_Dirty || isInitialUpdate); // bool m_Dirty || isInitialUpdate
	outBitStream->Read(m_DynamicParams.cannonVelocity); // double_t m_DynamicParams.cannonVelocity
	outBitStream->Read(m_DynamicParams.cannonRefireRate); // double_t m_DynamicParams.cannonRefireRate
	outBitStream->Read(m_DynamicParams.cannonMinDistance); // double_t m_DynamicParams.cannonMinDistance
	outBitStream->Read(m_DynamicParams.cameraBarrelOffset.GetX()); // float_t m_DynamicParams.cameraBarrelOffset.GetX()
	outBitStream->Read(m_DynamicParams.cameraBarrelOffset.GetY()); // float_t m_DynamicParams.cameraBarrelOffset.GetY()
	outBitStream->Read(m_DynamicParams.cameraBarrelOffset.GetZ()); // float_t m_DynamicParams.cameraBarrelOffset.GetZ()
	outBitStream->Read(m_DynamicParams.cannonAngle); // float_t m_DynamicParams.cannonAngle
	outBitStream->Read(m_DynamicParams.facing.GetX()); // float_t m_DynamicParams.facing.GetX()
	outBitStream->Read(m_DynamicParams.facing.GetY()); // float_t m_DynamicParams.facing.GetY()
	outBitStream->Read(m_DynamicParams.facing.GetZ()); // float_t m_DynamicParams.facing.GetZ()
	outBitStream->Read(m_CurrentPlayerID); // LWOOBJID m_CurrentPlayerID
	outBitStream->Read(m_DynamicParams.cannonTimeout); // float_t m_DynamicParams.cannonTimeout
	outBitStream->Read(m_DynamicParams.cannonFOV); // float_t m_DynamicParams.cannonFOV
	} 
  
TEST_F(SimplePhysicsTest, SimplePhysicsComponentConstructionTest) {
	outBitStream->Read(m_ClimbableType != eClimbableType::CLIMBABLE_TYPE_NOT); //  m_ClimbableType != eClimbableType::CLIMBABLE_TYPE_NOT
	outBitStream->Read(m_ClimbableType); //  m_ClimbableType
	outBitStream->Read(m_DirtyVelocity || bIsInitialUpdate); //  m_DirtyVelocity || bIsInitialUpdate
	outBitStream->Read(m_Velocity); //  m_Velocity
	outBitStream->Read(m_AngularVelocity); //  m_AngularVelocity
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_PhysicsMotionState); // uint32_t m_PhysicsMotionState
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(m_IsDirty || bIsInitialUpdate); //  m_IsDirty || bIsInitialUpdate
	outBitStream->Read(m_Position.x); //  m_Position.x
	outBitStream->Read(m_Position.y); //  m_Position.y
	outBitStream->Read(m_Position.z); //  m_Position.z
	outBitStream->Read(m_Rotation.x); //  m_Rotation.x
	outBitStream->Read(m_Rotation.y); //  m_Rotation.y
	outBitStream->Read(m_Rotation.z); //  m_Rotation.z
	outBitStream->Read(m_Rotation.w); //  m_Rotation.w
	} 
  
TEST_F(SkillTest, SkillComponentConstructionTest) {
	if (bIsInitialUpdate) outBitStream->ReadBit(); // bool bIsInitialUpdate) outBitStream->ReadBit(
	} 
  
TEST_F(SoundTriggerTest, SoundTriggerComponentConstructionTest) {
	outBitStream->Read(dirty); //  dirty
	outBitStream->Read(this->musicCues.size()); // uint8_t this->musicCues.size()
	outBitStream->Read(musicCue.name.size()); // uint8_t musicCue.name.size()
	outBitStream->Read(musicCue.name.c_str(), musicCue.name.size()); //  musicCue.name.c_str(), musicCue.name.size()
	outBitStream->Read(musicCue.result); // uint32_t musicCue.result
	outBitStream->Read(musicCue.boredomTime); // float_t musicCue.boredomTime
	outBitStream->Read(0); // uint16_t 0
	outBitStream->Read(this->guids.size()); // uint8_t this->guids.size()
	outBitStream->Read(guid.GetData1()); // uint32_t guid.GetData1()
	outBitStream->Read(guid.GetData2()); // uint16_t guid.GetData2()
	outBitStream->Read(guid.GetData3()); // uint16_t guid.GetData3()
	outBitStream->Read(guidSubPart); // uint8_t guidSubPart
	outBitStream->Read(1); // uint32_t 1
	outBitStream->Read(this->mixerPrograms.size()); // uint8_t this->mixerPrograms.size()
	outBitStream->Read(mixerProgram.size()); // uint8_t mixerProgram.size()
	outBitStream->Read(mixerProgram.c_str(), mixerProgram.size()); //  mixerProgram.c_str(), mixerProgram.size()
	outBitStream->Read(1); // uint32_t 1
	} 
  
TEST_F(SwitchTest, SwitchComponentConstructionTest) {
	outBitStream->Read(m_Active); //  m_Active
	} 
  
TEST_F(VehiclePhysicsTest, VehiclePhysicsComponentConstructionTest) {
	outBitStream->Read(bIsInitialUpdate || m_DirtyPosition); //  bIsInitialUpdate || m_DirtyPosition
	outBitStream->Read(m_Position); //  m_Position
	outBitStream->Read(m_Rotation); //  m_Rotation
	outBitStream->Read(m_IsOnGround); //  m_IsOnGround
	outBitStream->Read(m_IsOnRail); //  m_IsOnRail
	outBitStream->Read(bIsInitialUpdate || m_DirtyVelocity); //  bIsInitialUpdate || m_DirtyVelocity
	outBitStream->Read(m_Velocity); //  m_Velocity
	outBitStream->Read(bIsInitialUpdate || m_DirtyAngularVelocity); //  bIsInitialUpdate || m_DirtyAngularVelocity
	outBitStream->Read(m_AngularVelocity); //  m_AngularVelocity
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(0.0f); //  0.0f
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(5); // uint8_t 5
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	} 
  
TEST_F(VendorTest, VendorComponentConstructionTest) {
	outBitStream->ReadBit(); // bool 
	outBitStream->ReadBit(); // bool 
	outBitStream->Read(HasCraftingStation()); //  HasCraftingStation()
	} 
  

